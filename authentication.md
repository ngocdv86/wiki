<div id="top"></div>

<br />
<div align="center">
  <h1 align="center">Authentication</h1>
</div>

## Main concept.

- ### SSO (Single Sign-On)

  Single Sign-On, lÃ  cÆ¡ cháº¿ cho phÃ©p ngÆ°á»i dÃ¹ng cÃ³ thá»ƒ truy cáº­p nhiá»u trang web, á»©ng dá»¥ng mÃ  chá»‰ cáº§n Ä‘Äƒng nháº­p má»™t láº§n. Má»™t khi Ä‘Ã£ Ä‘Æ°á»£c Ä‘á»‹nh danh á»Ÿ má»™t trang website A, thÃ¬ cÅ©ng sáº½ Ä‘Æ°á»£c Ä‘á»‹nh danh tÆ°Æ¡ng tá»± á»Ÿ website B mÃ  khÃ´ng cáº§n láº·p láº¡i thao tÃ¡c Ä‘Äƒng nháº­p.

  Má»™t user khi Ä‘Äƒng nháº­p vÃ o há»‡ thá»‘ng A thÃ¬ domain cá»§a A sáº½ lÆ°u thÃ´ng tin Ä‘á»‹nh danh vÃ o cookie, Ä‘á»ƒ user nÃ y cÅ©ng lÃ  Ä‘Ã£ Ä‘Äƒng nháº­p khi truy cáº­p vÃ o há»‡ thá»‘ng B thÃ¬ domain B sáº½ pháº£i Ä‘á»c Ä‘Æ°á»£c cookie cá»§a A táº¡o ra, nhÆ°ng Ä‘iá»u nÃ y lÃ  khÃ´ng thá»ƒ. Vá»›i cÃ¡c trÃ¬nh duyá»‡t hiá»‡n nay, domain chá»‰ cÃ³ thá»ƒ truy cáº­p cookie do chÃ­nh nÃ³ táº¡o ra.

  Má»—i giao thá»©c single sign-on sáº½ cÃ³ cÆ¡ cháº¿ chia sáº» khÃ¡c nhau, nhÆ°ng Ä‘iá»ƒm chung Ä‘á»u lÃ  táº¡o ra má»™t domain trung tÃ¢m (central domain). Qua domain nÃ y, thÃ´ng tin vá» cookie sáº½ Ä‘Æ°á»£c chia sáº» Ä‘áº¿n cÃ¡c domain con.
  <div align="center">
      <img src="images/auth/sso.png" alt="Logo" width="860" height="600">
    </div>
    <br />

- ### JWT

  - Symetric vs Asymetric

  ```js
  // Asymetric
  // Use case: NhÆ° mÃ´ hÃ¬nh SSO bÃªn trÃªn, Auth Server lÃ  nÆ¡i signed jwt token, vÃ  chá»‰ Auth Server giá»¯ private key. CÃ¡c service khÃ¡c cÃ³ public key Ä‘á»ƒ verify nhÆ°ng khÃ´ng thá»ƒ sá»­a Ä‘á»•i thÃ´ng tin trong payload
  "use strict";
  const fs = require("fs");
  const jwt = require("jsonwebtoken");

  // Keys generated by http://travistidwell.com/jsencrypt/demo/ and saved to disk.
  // The algorithm must be set to "RS256"

  // Private Key, Public Key (must read as utf8)
  const privateKey = fs.readFileSync("./private.key", "utf8");
  const publicKey = fs.readFileSync("./public.key", "utf8");

  const token = jwt.sign(payload, privateKey, signOptions);

  // Notice the `algorithms: ["RS256"]` which goes with public/private keys
  const verified = jwt.verify(token, publicKey, verifyOptions);
  const decoded = jwt.decode(token, { complete: true });
  ```

  ```js
  // Symetric:
  // Peer-to-peer, cáº£ sender vÃ  reciever Ä‘á»u cÃ³ thá»ƒ sá»­a thÃ´ng tin payload.

  "use strict";
  const jwt = require("jsonwebtoken");

  const secretKey = "shhhhhh";

  const token = jwt.sign(payload, secretKey, signOptions);

  const verified = jwt.verify(token, secretKey, verifyOptions);
  const decoded = jwt.decode(token, { complete: true });
  ```

  - Gá»“m 3 thÃ nh pháº§n: header, payload, signature.
  - Signature = `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`, náº¿u dÃ¹ng thuáº­t toÃ¡n HMACSHA256. VÃ¬ váº­y dÃ¹ cÃ³ Ä‘á»c Ä‘Æ°á»£c thÃ´ng tin payload cÅ©ng khÃ´ng Ä‘á»ƒ sá»­a thÃ´ng tin, do khÃ´ng cÃ³ `secret` Ä‘á»ƒ táº¡o `Signature` tÆ°Æ¡ng á»©ng.
  - NÃªn Ä‘áº·t secretKey Ä‘á»§ dÃ i Ä‘á»ƒ háº¡n cháº¿ Bruteforcing.

    _Please note the RFC7518 standard states that "A key of the same size as the hash output (for instance, 256 bits for "HS256") or larger MUST be used with this algorithm." Auth0 secret keys exceed this requirement making cracking via this or similar tools all but impossible_

    [Xem thÃªm](https://auth0.com/blog/brute-forcing-hs256-is-possible-the-importance-of-using-strong-keys-to-sign-jwts/#Brute-Forcing-a-HS256-JSON-Web-Token)

- ### Encrypt Password
- ### Refresh token

  - A refresh token can help you balance security with usability. Since refresh tokens are typically longer-lived, you can use them to request new access tokens after the shorter-lived access tokens expire.
  - We need to have a strategy in place that limits or curtails their usage if they ever get leaked or become compromised.

    - Refresh Token Rotation:

      ğŸ± Legitimate User uses ğŸ”„ **Refresh Token** to get a **New refresh-access token**

    - Refresh Token Automatic Reuse Detection:

      ğŸ± Legitimate User uses ğŸ”„ **Refresh Token 1** to get a **New refresh-access token** pair.

      The ğŸš“ **Auth0 Authorization Server** returns ğŸ”„ **Refresh Token 2** and ğŸ”‘ **Access Token 2** to ğŸ± Legitimate User.

      ğŸ˜ˆ Malicious User then attempts to use ğŸ”„ **Refresh Token 1** to get a new access token. Pure evil!

      The ğŸš“ **Auth0 Authorization Server** has been keeping track of all the refresh tokens descending from the original refresh token. That is, it has created a "token family".

      The ğŸš“ **Auth0 Authorization Server** recognizes that someone is reusing ğŸ”„ Refresh Token 1 and immediately invalidates the refresh token family, including ğŸ”„ Refresh Token 2.

      The ğŸš“ **Auth0 Authorization Server** returns an Access Denied response to ğŸ˜ˆ Malicious User.

      ğŸ”‘ **Access Token 2** expires, and ğŸ± Legitimate User attempts to use ğŸ”„ **Refresh Token 2** to request a **New refresh-access token** pair.

      The ğŸš“ **Auth0 Authorization Server** returns an Access Denied response to ğŸ± Legitimate User.

- ### CÃ¡c loáº¡i token
- ### REF
  [Single Sign-On (SSO) lÃ  gÃ¬, hoáº¡t Ä‘á»™ng ra sao?](https://viblo.asia/p/single-sign-on-sso-la-gi-hoat-dong-ra-sao-bWrZn4oQ5xw)
  [What Are Refresh Tokens and How to Use Them Securely](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/#Keeping-Refresh-Tokens-Secure)
  [vladwulf/nestjs-jwts](https://github.com/vladwulf/nestjs-jwts/blob/main/src/auth/auth.service.ts)
  <p align="right">(<a href="#top">Back to top</a>)</p>
