<div id="top"></div>

<br />
<div align="center">
  <h1 align="center">Authentication</h1>
</div>

## Main concept.

- ### SSO (Single Sign-On)

  Single Sign-On, là cơ chế cho phép người dùng có thể truy cập nhiều trang web, ứng dụng mà chỉ cần đăng nhập một lần. Một khi đã được định danh ở một trang website A, thì cũng sẽ được định danh tương tự ở website B mà không cần lặp lại thao tác đăng nhập.

  Một user khi đăng nhập vào hệ thống A thì domain của A sẽ lưu thông tin định danh vào cookie, để user này cũng là đã đăng nhập khi truy cập vào hệ thống B thì domain B sẽ phải đọc được cookie của A tạo ra, nhưng điều này là không thể. Với các trình duyệt hiện nay, domain chỉ có thể truy cập cookie do chính nó tạo ra.

  Mỗi giao thức single sign-on sẽ có cơ chế chia sẻ khác nhau, nhưng điểm chung đều là tạo ra một domain trung tâm (central domain). Qua domain này, thông tin về cookie sẽ được chia sẻ đến các domain con.
  <div align="center">
      <img src="images/auth/sso.png" alt="Logo" width="860" height="600">
    </div>
    <br />

- ### JWT

  - Symetric vs Asymetric

  ```js
  // Asymetric
  // Use case: Như mô hình SSO bên trên, Auth Server là nơi signed jwt token, và chỉ Auth Server giữ private key. Các service khác có public key để verify nhưng không thể sửa đổi thông tin trong payload
  "use strict";
  const fs = require("fs");
  const jwt = require("jsonwebtoken");

  // Keys generated by http://travistidwell.com/jsencrypt/demo/ and saved to disk.
  // The algorithm must be set to "RS256"

  // Private Key, Public Key (must read as utf8)
  const privateKey = fs.readFileSync("./private.key", "utf8");
  const publicKey = fs.readFileSync("./public.key", "utf8");

  const token = jwt.sign(payload, privateKey, signOptions);

  // Notice the `algorithms: ["RS256"]` which goes with public/private keys
  const verified = jwt.verify(token, publicKey, verifyOptions);
  const decoded = jwt.decode(token, { complete: true });
  ```

  ```js
  // Symetric:
  // Peer-to-peer, cả sender và reciever đều có thể sửa thông tin payload.

  "use strict";
  const jwt = require("jsonwebtoken");

  const secretKey = "shhhhhh";

  const token = jwt.sign(payload, secretKey, signOptions);

  const verified = jwt.verify(token, secretKey, verifyOptions);
  const decoded = jwt.decode(token, { complete: true });
  ```

  - Gồm 3 thành phần: header, payload, signature.
  - Signature = `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`, nếu dùng thuật toán HMACSHA256. Vì vậy dù có đọc được thông tin payload cũng không để sửa thông tin, do không có `secret` để tạo `Signature` tương ứng.
  - Nên đặt secretKey đủ dài để hạn chế Bruteforcing.

- ### Encrypt Password
- ### Refresh token
- ### Các loại token
- ### REF
  [Single Sign-On (SSO) là gì, hoạt động ra sao?](https://viblo.asia/p/single-sign-on-sso-la-gi-hoat-dong-ra-sao-bWrZn4oQ5xw)
  <p align="right">(<a href="#top">Back to top</a>)</p>
